name: Deploy (CI:Deploy → predeployed ECR image)

on:
  pull_request:
    types: [closed]
    branches: [ master ]

permissions:
  contents: read
  pull-requests: read

jobs:
  deploy:
    # Only run when PR is merged and labeled CI:Deploy
    if: >
      github.event.pull_request.merged == true &&
      contains(join(github.event.pull_request.labels.*.name, ','), 'CI:Deploy')

    runs-on: ubuntu-latest

    env:
      # AWS creds (IAM user) — set as repo secrets
      AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION:            ${{ vars.AWS_REGION }}
      AWS_DEFAULT_REGION:    ${{ vars.AWS_REGION }}

      # ECR repo with your devnet images
      ECR_DEPLOY_REGISTRY:          ${{ vars.ECR_DEPLOY_REGISTRY }}
      IMAGE_DEPLOY_URI:             ${{ vars.IMAGE_DEPLOY_URI }}

      # deterministic dev account address on geth --dev
      DEV_ACCOUNT:           ${{ secrets.DEV_ACCOUNT }}

      # local bind mount to capture chain state
      CHAIN_DIR:             .chain

    steps:
      - name: Checkout merged code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref || 'master' }}

      - name: Compute 6-char tag
        id: tag
        run: |
          SHORT=$(echo "${{ github.event.pull_request.merge_commit_sha }}" | cut -c1-6)
          echo "short=$SHORT" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "$ECR_DEPLOY_REGISTRY"

      - name: Pick devnet source image (prefer main-<sha>, fallback to latest)
        id: pick
        run: |
          SRC_TAG="main-${{ steps.tag.outputs.short }}"
          if docker pull "$IMAGE_DEPLOY_URI:$SRC_TAG" ; then
            echo "src=$IMAGE_DEPLOY_URI:$SRC_TAG" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::$IMAGE_DEPLOY_URI:$SRC_TAG not found, falling back to :latest"
            docker pull "$IMAGE_DEPLOY_URI:latest"
            echo "src=$IMAGE_DEPLOY_URI:latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Start devnet (detached) with unlocked dev account
        run: |
          set -euo pipefail
          rm -rf "$CHAIN_DIR"
          mkdir -p "$CHAIN_DIR"

          docker run -d --name devnet \
            -p 8545:8545 \
            -v "$PWD/$CHAIN_DIR":/root/.ethereum \
            --entrypoint "" \
            "${{ steps.pick.outputs.src }}" \
            geth --dev \
                 --http --http.addr 0.0.0.0 \
                 --http.api eth,net,web3,txpool,debug \
                 --unlock "$DEV_ACCOUNT" \
                 --password /dev/null \
                 --allow-insecure-unlock

      - name: Wait for RPC
        run: |
          for i in {1..60}; do
            if curl -sf -H 'content-type: application/json' \
                --data '{"jsonrpc":"2.0","id":1,"method":"web3_clientVersion","params":[]}' \
                http://127.0.0.1:8545 >/dev/null; then
              echo "RPC up"; exit 0
            fi
            sleep 1
          done
          echo "RPC not responding"; docker logs devnet || true; exit 1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Hardhat deps
        working-directory: hardhat
        run: npm ci

      - name: Compile & deploy Hardhat sample to devnet
        working-directory: hardhat
        env:
          # your script reads artifacts via hre, and signs with a local PK
          DEPLOYER_PK: ${{ secrets.DEPLOYER_PK }} 
          RPC_URL:     http://127.0.0.1:8545
        run: |
          npx hardhat clean || true
          npx hardhat compile
          npx hardhat run scripts/deploy.ts --network localdevnet

      - name: Stop devnet
        if: always()
        run: |
          docker logs devnet || true
          docker rm -f devnet || true

      - name: Show chain dir contents
        run: |
          echo "Captured chain state at $CHAIN_DIR:"
          find "$CHAIN_DIR" -maxdepth 2 -type f | head -n 50 || true

      - name: Build predeployed image
        run: |
          PRE_TAG="pre-${{ steps.tag.outputs.short }}"
          echo "Building predeployed image: $IMAGE_DEPLOY_URI:$PRE_TAG"

          cat > Dockerfile.pre <<'EOF'
          ARG BASE_FROM
          FROM ${BASE_FROM}
          # bring in the chain data captured during deployment
          COPY .chain /root/.ethereum
          # rely on base entrypoint / start script; RPC is exposed by base
          EOF

          docker build \
            --build-arg BASE_FROM="${{ steps.pick.outputs.src }}" \
            -f Dockerfile.pre \
            -t "$IMAGE_DEPLOY_URI:$PRE_TAG" .

          docker push "$IMAGE_DEPLOY_URI:$PRE_TAG"
          echo "pushed=$IMAGE_DEPLOY_URI:$PRE_TAG" >> $GITHUB_OUTPUT

          echo "Predeployed image: $IMAGE_DEPLOY_URI:pre-${{ steps.tag.outputs.short }}"

      # - name: Print result tag
      #   run: echo "Predeployed image: $IMAGE_DEPLOY_URI:pre-${{ steps.tag.outputs.short }}"
