name: Deploy (CI:Deploy → predeployed ECR image)

on:
  pull_request:
    types: [closed]
    branches: [ master ]

permissions:
  contents: read
  pull-requests: read

jobs:
  deploy:
    # Only run when PR is merged and labeled CI:Deploy
    if: >
      github.event.pull_request.merged == true &&
      contains(join(github.event.pull_request.labels.*.name, ','), 'CI:Deploy')

    runs-on: ubuntu-latest

    env:
      # AWS creds (IAM user) — set as repo secrets
      AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION:            ${{ vars.AWS_REGION }}
      AWS_DEFAULT_REGION:    ${{ vars.AWS_REGION }}

      # ECR repo with your devnet images
      ECR_DEPLOY_REGISTRY:          ${{ vars.ECR_DEPLOY_REGISTRY }}
      IMAGE_DEPLOY_URI:             ${{ vars.IMAGE_DEPLOY_URI }}

      #Dev net repo
      ECR_DEVNET_REGISTRY:          ${{ vars.ECR_DEVNET_REGISTRY }}
      IMAGE_DEVNET_URI:             ${{ vars.IMAGE_DEVNET_URI }} 

      # deterministic dev account address on geth --dev
      DEV_ACCOUNT:           ${{ secrets.DEV_ACCOUNT }}

      # local bind mount to capture chain state
      CHAIN_DIR:             .chain

    steps:
      - name: Checkout merged code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref || 'master' }}

      - name: Compute 6-char tag
        id: tag
        run: |
          SHORT=$(echo "${{ github.event.pull_request.merge_commit_sha }}" | cut -c1-6)
          echo "short=$SHORT" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "$ECR_DEVNET_REGISTRY"

      - name: Pick latest pushed devnet image from ECR
        id: pick
        run: |
          echo "Fetching latest tag for $IMAGE_DEVNET_URI from ECR..."
          # Query ECR for image tags sorted by pushed time
          LATEST_TAG=$(aws ecr describe-images \
            --repository-name geth-devnet \
            --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' \
            --output text)

          if [ "$LATEST_TAG" = "None" ] || [ -z "$LATEST_TAG" ]; then
            echo "No images found in ECR for $IMAGE_DEVNET_URI"
            exit 1
          fi

          echo "Latest tag found: $LATEST_TAG"
          docker pull "$IMAGE_DEVNET_URI:$LATEST_TAG"
          echo "src=$IMAGE_DEVNET_URI:$LATEST_TAG" >> "$GITHUB_OUTPUT"

      - name: Start devnet (detached) with unlocked dev account
        run: |
          set -euo pipefail
          rm -rf "$CHAIN_DIR"
          mkdir -p "$CHAIN_DIR"

          docker run -d --name devnet \
            -p 8545:8545 \
            -v "$PWD/$CHAIN_DIR":/root/.ethereum \
            --entrypoint "" \
            "${{ steps.pick.outputs.src }}" \
            geth --dev \
                 --http --http.addr 0.0.0.0 \
                 --http.api eth,net,web3,txpool,debug \
                 --unlock "$DEV_ACCOUNT" \
                 --password /dev/null \
                 --allow-insecure-unlock

      - name: Wait for RPC
        run: |
          for i in {1..60}; do
            if curl -sf -H 'content-type: application/json' \
                --data '{"jsonrpc":"2.0","id":1,"method":"web3_clientVersion","params":[]}' \
                http://127.0.0.1:8545 >/dev/null; then
              echo "RPC up"; exit 0
            fi
            sleep 1
          done
          echo "RPC not responding"; docker logs devnet || true; exit 1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install Hardhat deps
        working-directory: hardhat
        run: npm ci

      - name: Compile & deploy Hardhat sample to devnet
        id: hhdeploy
        working-directory: hardhat
        env:
          DEPLOYER_PK: ${{ secrets.DEPLOYER_PK }}
          RPC_URL:     http://127.0.0.1:8545
        run: |
          set -e
          npx hardhat clean || true
          npx hardhat compile
          OUT="$(npx hardhat run scripts/deploy.ts --network localdevnet | tee /dev/stderr)"
          ADDR="$(echo "$OUT" | awk '/Lock deployed to:/ {print $4}')"
          CHAINID="$(echo "$OUT" | awk '/Connected chainId:/ {print $3}')"
          echo "Deployed at: $ADDR on chainId=$CHAINID"
          if [ -z "$ADDR" ] || [ "$ADDR" = "0x" ]; then
            echo "Deploy failed to produce a contract address"; exit 1
          fi
          echo "lock_address=$ADDR" >> "$GITHUB_OUTPUT"

      - name: Stop devnet
        if: always()
        run: |
          docker logs devnet || true
          docker rm -f devnet || true

      - name: Fix chain permissions and remove non-copyable files
        run: |
          # Ensure we can read the chain dir (container wrote as root)
          sudo chown -R $(id -u):$(id -g) .chain || true
          sudo find .chain -type d -exec chmod 755 {} \; || true
          sudo find .chain -type f -exec chmod 644 {} \; || true
          # Remove IPC socket / lock files that break docker build context
          rm -f .chain/geth/geth.ipc || true
          rm -f .chain/geth/LOCK || true

      - name: (Optional) Write a temporary .dockerignore to exclude IPC/LOCK
        run: |
          printf "%s\n" \
            ".git" \
            "node_modules" \
            "hardhat/node_modules" \
            ".chain/geth/geth.ipc" \
            ".chain/geth/LOCK" \
            > .dockerignore

      - name: Show chain dir contents
        run: |
          echo "Captured chain state at $CHAIN_DIR:"
          find "$CHAIN_DIR" -maxdepth 2 -type f | head -n 50 || true

      - name: Build predeployed image
        run: |
          PRE_TAG="pre-${{ steps.tag.outputs.short }}"
          echo "Building predeployed image: $IMAGE_DEPLOY_URI:$PRE_TAG"

          cat > Dockerfile.pre <<'EOF'
          ARG BASE_FROM
          FROM ${BASE_FROM}
          # bring in the chain data captured during deployment
          COPY .chain /root/.ethereum
          # rely on base entrypoint / start script; RPC is exposed by base
          EOF

          docker build \
            --build-arg BASE_FROM="${{ steps.pick.outputs.src }}" \
            -f Dockerfile.pre \
            -t "$IMAGE_DEPLOY_URI:$PRE_TAG" .

          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "$ECR_DEPLOY_REGISTRY"

          docker push "$IMAGE_DEPLOY_URI:$PRE_TAG"
          echo "pushed=$IMAGE_DEPLOY_URI:$PRE_TAG" >> $GITHUB_OUTPUT

          echo "Predeployed image: $IMAGE_DEPLOY_URI:pre-${{ steps.tag.outputs.short }}"
      
      - name: Start predeployed devnet (detached)
        env:
          PRE_TAG: pre-${{ steps.tag.outputs.short }}
        run: |
          docker run -d --name devnet-pre \
            -p 8545:8545 \
            --entrypoint "" \
            "$IMAGE_DEPLOY_URI:$PRE_TAG" \
            geth --dev \
                 --datadir /root/.ethereum \
                 --http --http.addr 0.0.0.0 \
                 --http.api eth,net,web3,txpool,debug \
                 --allow-insecure-unlock
                 
      - name: Probe code on predeployed address
        env:
          LOCK_ADDRESS:  ${{ steps.hhdeploy.outputs.lock_address }}
        run: |
          CODE=$(curl -s -H 'content-type: application/json' \
            --data "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"eth_getCode\",\"params\":[\"$LOCK_ADDRESS\",\"latest\"]}" \
            http://127.0.0.1:8545 | jq -r .result)
          echo "Code at $LOCK_ADDRESS => $CODE"
          if [ "$CODE" = "0x" ] || [ -z "$CODE" ]; then
            echo "❌ No code at predeployed address. Check datadir copy / geth flags."
            docker logs devnet-pre || true
            exit 1
          fi


      - name: Wait for RPC (predeployed)
        run: |
          for i in {1..60}; do
            if curl -sf -H 'content-type: application/json' \
                --data '{"jsonrpc":"2.0","id":1,"method":"web3_clientVersion","params":[]}' \
                http://127.0.0.1:8545 >/dev/null; then
              echo "RPC up"; exit 0
            fi
            sleep 1
          done
          echo "RPC not responding"; docker logs devnet-pre || true; exit 1

      - name: Run Hardhat tests against predeployed image
        working-directory: hardhat
        env:
          RPC_URL:       http://127.0.0.1:8545
          LOCK_ADDRESS:  ${{ steps.hhdeploy.outputs.lock_address }}
        run: |
          # You can target a specific suite if you create a dedicated test file
          npx hardhat test --network localdevnet test/lock.pre.test.ts
        # Stop container afterwards
      - name: Stop predeployed devnet
        if: always()
        run: |
          docker logs devnet-pre || true
          docker rm -f devnet-pre || true

      

      # - name: Print result tag
      #   run: echo "Predeployed image: $IMAGE_DEPLOY_URI:pre-${{ steps.tag.outputs.short }}"
